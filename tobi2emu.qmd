# Configuring `emuR` for ToBI annotations

```{r}
#| echo: false

#Make sure that directory of emuDBs is empty before proceeding

d <- list.dirs('emu_databases')[-1]
unlink(d, recursive=TRUE)
```

## Objective and preliminaries

The objective of this chapter is to show how to go from a collection of `.wav` and `.txt` files to an Emu database that is useful for **to**nes-and-**b**reak **i**ndices (ToBI) annotation. More specifically, the aim is to configure a database to have a configuration like that shown in @fig-tobi.

![An Emu database with ToBI annotations.](img/figtobi.png){#fig-tobi}

The starting point is the text collection of Albanian data analyzed in @sec-forcedalignment.

We will also see how an annotation level with syllable structures can be ascertained from a database by creating an CV-style annotation level.

The assumption is that you already have an R project called `ipsR` and that it contains the directories `emu_databases` and `testsample`. If this is not the case, please go back and follow the preliminaries chapter.

```{r}
#| message: false
#| warning: false

library(tidyverse)
library(emuR)
library(wrassp)
sourceDir <- "./testsample"
targetDir <- "./emu_databases"
```

## Forced alignment

The first task is to apply forced alignment to these Albanian data. The commands will be presented in this section without detailed comment given that these were discussed in @sec-forcedalignment. The resulting Emu database will be stored as `alb2_DB` (to distinguish it from the one created in the @sec-forcedalignment).

We first create and load the Emu database using `convert_txtCollection()` and `load_emuDB()`, and subsequently use `runBASwebservice_all()` to run the MAUS pipeline over the data.

```{r}
#| warning: false

path.albanian <- file.path(sourceDir, "albanian")
convert_txtCollection(dbName = "alb2", 
                      sourceDir = path.albanian,
                      targetDir = targetDir,
                      verbose = FALSE)
alb2_DB <- load_emuDB(file.path(targetDir, "alb2_emuDB"),
                      verbose=FALSE)
runBASwebservice_all(alb2_DB,
                     transcriptionAttributeDefinitionName = "transcription", 
                     language = "sqi-AL",  
                     runMINNI = FALSE,
                     verbose = FALSE)
```

## Configuring a database for ToBI annotations

The database currently has an `ITEM` annotation level `ORT` that dominates an `ITEM` level `MAS` containing syllabifications. `MAS` dominates the `SEGMENT` level `MAU`, which contains the phonetic segmentation. You can confirm this either by `serve()`ing the database or by calling `summary(alb2_DB)`. 

Our next task is to add a level `Tone` for marking intonational events and to add a new `SEGMENT` level, `ORT2` which contains word-level segmentations. The tonal events of the `Tone` tier and annotations of the `ORT2` tier are to be linked automatically, just as in @fig-tobi.

Here are the steps needed:

- Create the `SEGMENT` level `ORT2` containing word annotations linked to times.
- Create a `Tone` level and link it to `ORT2`.
- Calculate and display pitch tracks.
- Annotate the `Tone` level and link the annotations automatically to the word level annotations in `ORT2`.

### Create and display word level annotations

This is a four step process:

- Create a `SEGMENT`-type annotation level called `ORT2`.

As covered in @sec-praat2emu, this can be done with the `add_levelDefinition()` function like so:

```{r}
add_levelDefinition(alb2_DB, 
                    name="ORT2",
                    type="SEGMENT",
                    verbose=FALSE)
```

We can confirm that this step was successful with `list_levelDefinitions()`:

```{r}
list_levelDefinitions(alb2_DB)
```

- Make a list of all words in the database.

We can do this by using the `query()` function to find all annotations in the `ORT` level. 

```{r}
text.s <- query(alb2_DB, "[ORT =~ .*]")
text.s
```

We can use the segment list generated by the `query()` above to populate our new level `ORT2`. We simply need to change the columns `attribute` and `level` so they show the value `ORT2` instead of `ORT`:

```{r}
text.s$attribute <- "ORT2"
text.s$level <- "ORT2"
```

- Add word-level annotations to `ORT2`.

We can now pass `text.s` on to the function `create_itemsInLevel()` like so:

```{r}
create_itemsInLevel(alb2_DB, text.s,
                    verbose=FALSE)
```

It is now possible to `query()` the word level annotations directly from `ORT2`:

```{r}
query(alb2_DB, "[ORT2 =~ .*]")
```

- Display the annotations of `ORT2` time-aligned to the signals.

Because `ORT2` is a `SEGMENT`-type level and not an `ITEM`-type level, we can now display word-level annotations underneath the signals in the `EMU-webApp`. However, if we `serve()` the database now, only the segment-level annotations in `MAU` can be seen. As covered in @sec-praat2emu, this can be controlled with the `set_levelCanvasesOrder()` function like so:

```{r}
set_levelCanvasesOrder(alb2_DB,
                       perspectiveName = "default",
                       order = "ORT2")
```

`serve()`ing the database now will show only the word-level annotations in `ORT2` underneath the signals:

```{r}
#| eval: false

serve(alb2_DB, useViewer = FALSE)
```

### Create a `Tone` level and link it to `ORT2`

This is a three-step process:

- Create the new annotation level named `Tone`.

We do this with the `add_levelDefinition()` function, just as we did earlier when creating `ORT2`. `Tone` should be an `EVENT`-type level, since we want to mark intonational targets as single points in time. 

```{r}
add_levelDefinition(alb2_DB, 
                    name = "Tone", 
                    type = "EVENT",
                    verbose = FALSE)
```

- Create the link between `Tone` and `ORT2`.

The function `list_linkDefinitions()` shows that there are no currently no links between `Tone` and `ORT2`:

```{r}
list_linkDefinitions(alb2_DB)
```

In order to allow for annotations in the two levels to be queried relative to each other, they need to be linked. On the assumption that a word can be associated with one or more tones, but that a given tone can only be associated with one word, the association between the two levels should be `ONE_TO_MANY`. The levels should therefore be linked in the following way with the `add_linkDefinitions()` function:

```{r}
add_linkDefinition(alb2_DB, 
                   type = "ONE_TO_MANY", 
                   superlevelName = "ORT2", 
                   sublevelName = "Tone")
```

Calling `list_linkDefinitions()` again will confirm that the two levels are now linked:

```{r}
list_linkDefinitions(alb2_DB)
```

- Display the `Tone` level.

As before, this can be done with the `set_levelCanvasesOrder()` function. We now need to specify both `Tone` and `ORT2` in the `order` argument, like so:

```{r}
set_levelCanvasesOrder(alb2_DB,
                       perspectiveName = "default",
                       order = c("Tone", "ORT2"))
```

`serve()`ing the database again will now show both the `Tone` and `ORT2` levels underneath the signals:

```{r}
#| eval: false

serve(alb2_DB, useViewer = FALSE)
```

### Calculating and displaying *F*~0~

This is a three-step process. Most of these steps were covered in @sec-praat2emu, so only a brief summary is given below.

- Calculate *F*~0~.

We can do this using the `add_ssffTrackDefinition` with the "on the fly function" `mhsF0` (see @sec-praat2emu).

```{r}
add_ssffTrackDefinition(alb2_DB, 
                        name = "pitch", 
                        onTheFlyFunctionName = "mhsF0",
                        verbose = FALSE)
```

We can confirm that this worked with the function `list_ssffTrackDefinitions()`:

```{r}
list_ssffTrackDefinitions(alb2_DB)
```

- Configure the database to show the *F*~0~ track.

As explained in @sec-praat2emu, the pitch data can be displayed with the function `set_signalCanvasesOrder`. Currently, only the waveform and spectrogram are displayed, as confirmed with:

```{r}
get_signalCanvasesOrder(alb2_DB, perspectiveName = "default")
```

In order to display the pitch data underneath the spectrogram, use `set_signalCanvasesOrder()` like follows:

```{r}
set_signalCanvasesOrder(alb2_DB, 
                        perspectiveName = "default",
                        order = c("OSCI", "SPEC", "pitch"))
```

(Alternatively, if you have installed and loaded `emuhelpeR`, you can display it like so: `alb2DB %>% add_signal_canvas("pitch")`.)

::: {.callout-note}
## Overlaying pitch on the spectrogram

If you have the library `emuhelpeR` installed, you can overlay pitch on the spectrogram using the `signal_on_spec()` function like so:

```{r}
#| warning: false

library(emuhelpeR)
alb2_DB %>% signal_on_spec("pitch")
```

(The function `clear_spec()` from `emuhelpeR` can be used to remove the signal from the spectrogram if you no longer wish to display it there.)

If you do not have `emuhelpeR` installed, the process is a bit more intricate. For this you will usually use a plain text editor to change the database's configuration JSON file. This file always has the same name as the database + `config.json` and is stored in the same directory as the database. Once you've found this file, you can proceed as follows:

- Optionally make a backup copy of the the `alb2_DBconfig.json` file in case anything goes wrong.
- Open `alb2_DBconfig.json` with a plain text editor, e.g. Notepad in Windows.
- Search the file for the text string `assign`. You should find a line with the following contents: 

`"assign": [],`

- Carefully replace this line with the following:

`"assign": [{ "signalCanvasName": "SPEC", "ssffTrackName": "pitch" }],`

- Save the file. 
- `serve()` the database again. 

In principle, the configuration JSON file can also be edited in R, e.g. using the `rjson` library. You should probably avoid this unless you're an advanced R user -- it's a finnicky process and a lot can go wrong.

:::

### Automatically linking annotations at the `Tone` level

The first task here is to make a few annotations. More specifically, add two pitch targets (e.g., `L*` to *Lena*, `L*` to *leu*) to the utterance `0001BF_1syll_1` as in @fig-tobi. See @sec-wav2emu for details of how to annotate in the `Emu-webApp`.

```{r}
#| echo: false

annot_info <- data.frame(session = rep('0000', 2), 
                         bundle = rep('0001BF_1syll_1', 2), 
                         level=rep('Tone', 2), attribute=rep('Tone', 2),
                         start = c(1200, 1800),
                         labels = c('L*', 'L*'), db_uuid=alb2_DB$UUID)
create_itemsInLevel(alb2_DB, annot_info, verbose=FALSE)
```

The next task is to automatically link the annotations at the `Tone` level to the corresponding words in the `ORT2` level. We can do this using the function `autobuild_linkFromTimes()`. This function links an annotation `Tone` level to an annotation at the `ORT2` level if the `Tone` annotation falls within the segment segment boundaries of the `ORT2` annotation. In other words, if the start and end times of an `ORT2` annotation are denoted *t*~1~ and *t*~2~, and the time of a `Tone` annotation is denoted simply *t*, then annotations at the two levels are linked if *t*~1~ < *t* < *t*~2~.

```{r}
autobuild_linkFromTimes(alb2_DB,
                        superlevelName = "ORT2",
                        sublevelName = "Tone",
                        verbose = FALSE)
```

If you `serve()` the database again and look at the hierarchy view, you can confirm that the links were indeed created.

It should now be possible to query tones with respect to words and vice-versa. For example, this function finds all words at the `ORT2` level with an annotated pitch accent at the `Tone` level. (Much more detail on querying follows in @sec-query!)

```{r}
query(alb2_DB, "[Tone =~.* ^ #ORT2 =~.*]")
```

## Adding a CV level

It can be helpful to have another annotation level in which every vowel corresponds to `V` and every consonant to `C`. This could then be used to establish the syllable types in the database. To do this, a new level called `CV` will be created that is an attribute of the `MAU` tier (which contains the segment annotations). We do this with the `add_attributeDefinition()` function:

```{r}
add_attributeDefinition(alb2_DB,
                        levelName = "MAU",
                        name = "CV",
                        verbose=FALSE)
```

Here we query all segments found at the `MAU` level in the database:

```{r}
mau.s <- query(alb2_DB, "MAU =~ .*")
mau.s
```

We can find unique segments (and their frequencies) using the `count` function available in the `tidyverse`:

```{r}
count(mau.s, labels)
```

We'll store the vowels in a vector `vowel_phonemes`:

```{r}
vowel_phonemes = c("a", "E", "i", "O", "u", "4")
```

With a few `tidyverse` commands, we can wrangle `mau.s` to have the label `V` for vowels and `C` for consonants (i.e., the labels that are *not* in the `vowel_phonemes` vector), and storing this as a new data frame called `new_items`.

We first change the values in the `attribute` column to `CV` using the `mutate()` function. We use the `rename()` function to change the `labels` column with phonemic annotations to `old_labels`. Finally we use `mutate()` in combination with `case_when()` to store the label `V` in `labels` wherever `old_labels` has a phonemic annotation found in our `vowel_phonemes` vector, and to store the label `C` in all other cases. For more resources on the `tidyverse` see the initial setup chapter. 

<!-- Add link to the initial setup chapter when all is done. -->


```{r}
new_items <- mau.s %>%
  mutate(attribute = "CV") %>%
  rename(old_labels = labels) %>%
  mutate(labels = case_when(old_labels %in% vowel_phonemes ~ "V",
                            TRUE ~ "C"))
```

Calling the `count()` function on `new_items` will give us the number of consonants and vowels in the database:

```{r}
count(new_items, labels)
```

We can add these new annotations to the attribute level `CV` using the `update_itemsInLevel()` function like so:

```{r}
update_itemsInLevel(alb2_DB, 
                    itemsToUpdate = new_items,
                    verbose = FALSE) 
```

We can now `query()` the `CV` level for all of its annotations:

```{r}
seglist_cv <- query(alb2_DB, "CV =~ .*")
count(seglist_cv, labels)
```

Perhaps more importantly, it is now possible to identify the different types of syllable structure. Recall that the `MAS` tier parses the `Phoneme` tier into syllables. 

```{r}
syll <- query(alb2_DB, "MAS =~ .*")
count(syll, labels)
```

Here are the syllables in terms of their representation at the `CV` tier:


```{r}
syll.cv <- requery_hier(alb2_DB, syll, level = "CV")
count(syll.cv, labels)
```

Don't worry if you don't yet understand how the `query`ing functions work -- much more on that in @sec-query!


## Functions introduced in this chapter

- `signal_on_spec()`: Overlays a signal, such as pitch, on top of the spectrogram in the `Emu-webApp`. (Requires `emuhelpeR` to be installed).
- `count()`: Provides a count of all instances of a factor variable in a data frame or tibble.
- `requery_hier()`: Requeries an emuDB based on an existing query. Will be discussed much more in @sec-query.